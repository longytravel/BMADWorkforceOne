# Story 2.6: Real-Time Heatmap Updates

**Epic:** Epic 2 - CvD Heatmap & Coverage Intelligence
**Story Points:** 3
**Priority:** P1 - High

---

## Status

Ready

---

## Story

**As a** WFM planner,
**I want** the heatmap to automatically update its colors and coverage data when I add or modify activities on the schedule,
**so that** I can see the immediate impact of scheduling decisions on service level coverage.

---

## Acceptance Criteria

1. **Given** an activity is added to the schedule, **When** the activity impacts a time interval, **Then** the affected heatmap cells should update their color to reflect new coverage
2. **Given** an activity is deleted from the schedule, **When** the activity previously contributed to coverage, **Then** the affected heatmap cells should update to show reduced coverage
3. **Given** an activity is moved to a different time, **When** both source and destination intervals change, **Then** both sets of heatmap cells should update correctly
4. **Given** multiple activities are changed in rapid succession, **When** updates are processed, **Then** the heatmap should update smoothly without flickering or visual glitches
5. **Given** the heatmap updates, **When** I hover over an updated cell, **Then** the tooltip should display the new coverage data immediately
6. **Given** the heatmap updates, **When** I click on an updated cell, **Then** the detail modal should show the current agent list and skills
7. **Given** coverage data updates, **When** the recalculation completes, **Then** the update should happen within 200ms to maintain responsive feel
8. **Given** the heatmap is visible, **When** I trigger a demo reset, **Then** the heatmap should reload with initial demo data

---

## Tasks / Subtasks

- [ ] Verify Zustand store integration (AC: 1, 2, 3)
  - [ ] Confirm recalculateCvD is called by addActivity action
  - [ ] Confirm recalculateCvD is called by updateActivity action
  - [ ] Confirm recalculateCvD is called by deleteActivity action
  - [ ] Review src/stores/appStore.ts implementation from Story 2.1

- [ ] Optimize CvDHeatmap component for reactive updates (AC: 4, 7)
  - [ ] Ensure cvdData is subscribed from Zustand store
  - [ ] Verify useMemo wraps grid transformation to prevent unnecessary recalculations
  - [ ] Verify React.memo on HeatmapCell to prevent all-cell re-renders
  - [ ] Test that only affected cells re-render (use React DevTools Profiler)

- [ ] Test add activity → heatmap update flow (AC: 1)
  - [ ] Create test scenario: Add meeting activity
  - [ ] Verify coverage calculator updates affected intervals
  - [ ] Verify heatmap cells change color (e.g., green → yellow)
  - [ ] Verify tooltip shows new coverage data
  - [ ] Verify detail modal shows new agent in list

- [ ] Test delete activity → heatmap update flow (AC: 2)
  - [ ] Create test scenario: Delete break activity
  - [ ] Verify coverage calculator updates affected intervals
  - [ ] Verify heatmap cells change color (e.g., green → red)
  - [ ] Verify tooltip shows reduced agent count

- [ ] Test move activity → heatmap update flow (AC: 3)
  - [ ] Create test scenario: Drag activity to different time (future Epic 3 feature)
  - [ ] For now, simulate via updateActivity with new startDateTime/endDateTime
  - [ ] Verify source interval coverage decreases
  - [ ] Verify destination interval coverage increases
  - [ ] Verify both cells update colors correctly

- [ ] Test rapid successive updates (AC: 4)
  - [ ] Create test scenario: Add 5 activities in quick succession
  - [ ] Verify no flickering or visual artifacts
  - [ ] Verify final state matches expected coverage
  - [ ] Consider debouncing recalculateCvD if performance issues occur

- [ ] Test demo reset integration (AC: 8)
  - [ ] Click reset button (FR23 from PRD, future Story 6.x)
  - [ ] For now, call store.resetDemo() programmatically
  - [ ] Verify heatmap reloads with original demo data
  - [ ] Verify loading state displays during reset

- [ ] Measure update performance (AC: 7)
  - [ ] Use React DevTools Profiler to measure render time
  - [ ] Use performance.now() to measure recalculateCvD execution time
  - [ ] Verify updates complete < 200ms
  - [ ] Log performance metrics to console

- [ ] Add visual feedback for updates (optional enhancement)
  - [ ] Consider brief highlight animation on updated cells
  - [ ] Use Tailwind transition classes (e.g., transition-colors duration-300)
  - [ ] Ensure animation doesn't distract from usability

---

## Dev Notes

### Architecture Context

This story ensures the **real-time reactivity** of the heatmap by verifying that Zustand store actions correctly trigger coverage recalculation and component re-renders. Most implementation was completed in Stories 2.1-2.2, so this story focuses on **integration testing and performance validation**.

### State Management Flow (Source: architecture/frontend-architecture.md)

**Activity Change → Heatmap Update Flow:**
```
1. User Action (add/update/delete activity)
   ↓
2. Zustand Action (addActivity/updateActivity/deleteActivity)
   ↓
3. Auto-triggered: recalculateCvD()
   ↓
4. CoverageCalculator updates cvdData array
   ↓
5. Zustand notifies subscribers (CvDHeatmap component)
   ↓
6. React re-renders affected HeatmapCell components
   ↓
7. User sees updated colors
```

**Store Actions (from Story 2.1):**
```typescript
addActivity: (activity) => set((state) => {
  state.activities.push(activity);
  get().recalculateCvD(); // Automatic update
  // ... audit log
}),

updateActivity: (id, updates) => set((state) => {
  const index = state.activities.findIndex(a => a.id === id);
  if (index !== -1) {
    Object.assign(state.activities[index], updates);
    get().recalculateCvD(); // Automatic update
  }
}),

deleteActivity: (id) => set((state) => {
  state.activities = state.activities.filter(a => a.id !== id);
  get().recalculateCvD(); // Automatic update
}),

recalculateCvD: () => set((state) => {
  const calculator = new CoverageCalculator();
  state.cvdData = calculator.recalculateAll(
    state.agents,
    state.activities,
    state.cvdData
  );
}),
```

[Source: architecture/frontend-architecture.md#State Management Architecture]

### Component Subscription (Source: architecture/frontend-architecture.md)

**CvDHeatmap Component:**
```typescript
export function CvDHeatmap() {
  // Subscribe to cvdData from Zustand
  const cvdData = useStore((state) => state.cvdData);

  // Memoize grid transformation
  const gridData = useMemo(() => {
    return transformCvDDataToGrid(cvdData);
  }, [cvdData]); // Re-compute only when cvdData changes

  return (
    <div className="heatmap-grid">
      {gridData.map(dataPoint => (
        <HeatmapCell key={dataPoint.intervalStart} dataPoint={dataPoint} />
      ))}
    </div>
  );
}
```

**HeatmapCell Component:**
```typescript
export const HeatmapCell = React.memo(({ dataPoint }: Props) => {
  const cellColor = getCellColor(dataPoint.riskLevel);

  return (
    <div
      className={`cell transition-colors duration-300`}
      style={{ backgroundColor: cellColor }}
    />
  );
});
```

**Performance Optimization:**
- `React.memo` prevents re-rendering cells that haven't changed
- Only cells with updated dataPoint props will re-render
- Transition CSS provides smooth color changes

[Source: architecture/frontend-architecture.md#Component Template Example]

### Coverage Calculator Performance (Source: Story 2.1)

**Optimized Recalculation:**
```typescript
recalculateAll(agents, activities, existingCvdData) {
  // Option 1: Full recalculation (simpler, < 500ms for 672 intervals)
  return this.generateAllIntervals(agents, activities);

  // Option 2: Incremental update (faster, only recalculate affected intervals)
  const affectedIntervals = this.findAffectedIntervals(activities);
  affectedIntervals.forEach(interval => {
    // Update only this interval
  });
}
```

**Performance Target:**
- Full recalculation: < 500ms (AC from Story 2.1)
- Update trigger to render: < 200ms (AC 7)
- Total: < 700ms from user action to visual update

[Source: Story 2.1 Dev Notes]

### Testing Approach

**Manual Testing Scenarios:**

**Scenario 1: Add Meeting Activity**
```typescript
// Programmatically add activity via store
const newMeeting = {
  id: 'meeting-123',
  agentId: 'agent-1',
  type: 'meeting',
  title: 'Team Standup',
  startDateTime: '2025-10-20T14:00:00Z',
  endDateTime: '2025-10-20T14:30:00Z',
  durationMinutes: 30,
  isMovable: true,
  color: '#10B981',
  metadata: {}
};

useStore.getState().addActivity(newMeeting);

// Expected: Heatmap cells at 14:00-14:30 (Monday) update colors
// Verify: Coverage decreases (agent in meeting, not answering calls)
// Result: Cells may change from green → yellow or yellow → red
```

**Scenario 2: Delete Break Activity**
```typescript
// Find and delete a break
const breakActivity = useStore.getState().activities.find(a => a.type === 'break');
useStore.getState().deleteActivity(breakActivity.id);

// Expected: Heatmap cells during break time update colors
// Verify: Coverage increases (agent returns from break)
// Result: Cells may change from yellow → green
```

**Scenario 3: Move Activity**
```typescript
// Update activity time
const activityId = 'activity-123';
useStore.getState().updateActivity(activityId, {
  startDateTime: '2025-10-20T16:00:00Z', // Changed from 14:00
  endDateTime: '2025-10-20T16:30:00Z'
});

// Expected: Original cells (14:00-14:30) and new cells (16:00-16:30) update
```

### Performance Measurement

**Using React DevTools Profiler:**
```typescript
// Wrap CvDHeatmap in Profiler during development
import { Profiler } from 'react';

function onRenderCallback(id, phase, actualDuration) {
  console.log(`${id} (${phase}) took ${actualDuration}ms`);
}

<Profiler id="CvDHeatmap" onRender={onRenderCallback}>
  <CvDHeatmap />
</Profiler>
```

**Using performance.now():**
```typescript
recalculateCvD: () => {
  const start = performance.now();

  set((state) => {
    const calculator = new CoverageCalculator();
    state.cvdData = calculator.recalculateAll(
      state.agents,
      state.activities,
      state.cvdData
    );
  });

  const duration = performance.now() - start;
  console.log(`Coverage recalculation took ${duration}ms`);

  if (duration > 200) {
    console.warn('WARNING: Recalculation exceeded 200ms target');
  }
}
```

### Handling Rapid Updates

**Issue:** Multiple rapid activity changes may cause excessive recalculations.

**Solution Options:**

**Option 1: Debounce (if needed)**
```typescript
import { debounce } from 'lodash-es'; // or custom implementation

const debouncedRecalculate = debounce(() => {
  get().recalculateCvD();
}, 100); // Wait 100ms after last change

addActivity: (activity) => set((state) => {
  state.activities.push(activity);
  debouncedRecalculate(); // Debounced instead of immediate
}),
```

**Option 2: Batch Updates (preferred)**
```typescript
addMultipleActivities: (activities) => set((state) => {
  state.activities.push(...activities);
  get().recalculateCvD(); // Single recalculation for batch
}),
```

**Recommendation:** Start with immediate recalculation. Only add debouncing if performance issues are observed.

### Visual Feedback Enhancement

**CSS Transition for Smooth Color Changes:**
```typescript
// HeatmapCell component
<div
  className="cell transition-colors duration-300 ease-in-out"
  style={{ backgroundColor: cellColor }}
/>
```

**Optional: Pulse Animation on Change**
```typescript
// Add animation class when cell updates
const [isUpdating, setIsUpdating] = useState(false);

useEffect(() => {
  setIsUpdating(true);
  const timer = setTimeout(() => setIsUpdating(false), 300);
  return () => clearTimeout(timer);
}, [dataPoint.coveragePercent]);

<div
  className={`cell transition-colors ${isUpdating ? 'animate-pulse' : ''}`}
/>
```

**Note:** Only implement if it enhances UX without distraction.

### Demo Reset Integration

**Reset Button (Future Story 6.x):**
```typescript
// In Header or Dashboard
<Button onClick={() => useStore.getState().resetDemo()}>
  Reset Demo
</Button>
```

**Store resetDemo Action:**
```typescript
resetDemo: async () => {
  set({ isLoading: true });
  const loader = new DataLoader();
  const data = await loader.loadAllDemoData();
  get().initializeData(data);
  // Automatically recalculates CvD during initializeData
}
```

### Edge Cases

**1. Activity spans multiple intervals:**
- Example: 30-min meeting (14:00-14:30) affects 2 intervals (14:00, 14:15)
- Verify both intervals update correctly

**2. Zero coverage after deletion:**
- Example: Delete last agent's shift, coverage drops to 0%
- Verify cell displays correct color (red)

**3. Concurrent updates:**
- Example: User adds activity while data is still loading
- Verify updates are queued or handled gracefully

### Previous Story Insights

From Story 2.1:
- recalculateCvD action exists and is integrated with activity actions
- Coverage calculator handles 672 intervals < 500ms

From Story 2.2:
- HeatmapCell uses React.memo for optimization
- Grid transformation uses useMemo

---

## Testing

### Test Framework
- **Tool:** Vitest 1.2+ with React Testing Library 14.1+
- **Location:** Integration test in `src/stores/appStore.test.ts` or `src/components/CvDHeatmap/CvDHeatmap.test.tsx`

[Source: architecture/testing-strategy.md#Frontend Tests]

### Integration Tests

```typescript
import { describe, it, expect } from 'vitest';
import { renderHook, act } from '@testing-library/react';
import { useStore } from '@/stores/appStore';

describe('Real-Time Heatmap Updates', () => {
  it('should update cvdData when activity is added', () => {
    const { result } = renderHook(() => useStore());

    const initialCoveragePercent = result.current.cvdData[0].coveragePercent;

    act(() => {
      result.current.addActivity({
        id: 'test-activity',
        agentId: 'agent-1',
        type: 'meeting',
        // ... other fields
      });
    });

    const updatedCoveragePercent = result.current.cvdData[0].coveragePercent;
    expect(updatedCoveragePercent).not.toBe(initialCoveragePercent);
  });

  it('should update cvdData when activity is deleted', () => {
    const { result } = renderHook(() => useStore());

    // Add activity first
    act(() => {
      result.current.addActivity({ id: 'test', /* ... */ });
    });

    const coverageAfterAdd = result.current.cvdData[0].coveragePercent;

    // Delete activity
    act(() => {
      result.current.deleteActivity('test');
    });

    const coverageAfterDelete = result.current.cvdData[0].coveragePercent;
    expect(coverageAfterDelete).not.toBe(coverageAfterAdd);
  });

  it('should complete recalculation within 200ms', () => {
    const { result } = renderHook(() => useStore());

    const start = performance.now();

    act(() => {
      result.current.recalculateCvD();
    });

    const duration = performance.now() - start;
    expect(duration).toBeLessThan(200);
  });
});
```

[Source: architecture/testing-strategy.md#Unit Test Examples]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-19 | 1.0 | Story created | Bob (Scrum Master) |

---

## Dev Agent Record

### Agent Model Used

*To be populated by dev agent during implementation*

### Debug Log References

*To be populated by dev agent during implementation*

### Completion Notes List

*To be populated by dev agent during implementation*

### File List

*To be populated by dev agent during implementation*

---

## QA Results

*To be populated by QA agent after story review*

---
